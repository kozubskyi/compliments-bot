const axios = require('axios')
const { isItKozubskyi, isItLenaRak, sendInfoMessageToCreator } = require('../helpers/helpers')
const handleError = require('./handle-error')

function separateFirstWord(msg) {
	const msgArr = msg.split(' ')
	const cmd = msgArr.shift()
	const text = msgArr.join(' ')

	return [cmd, text]
}

async function handleCreatorCommands(ctx) {
	let reply

	const [command, rest] = separateFirstWord(ctx.message.text)

	const { DB_BASE_URL } = process.env

	if (command === 'add') {
		const { data } = await axios.post(`${DB_BASE_URL}/compliments`, { text: rest })

		reply = `‚úÖ –ö–æ–º–ø–ª—ñ–º–µ–Ω—Ç–∏–∫ –¥–æ–¥–∞–Ω–æ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö: ${JSON.stringify(data)}`
	} else if (command === 'show') {
		const { data } = await axios.get(`${DB_BASE_URL}/compliments/${rest}`)

		reply = JSON.stringify(data)
	} else if (command === 'del') {
		const [key, idOrText] = separateFirstWord(rest)

		const { data } = await axios.delete(`${DB_BASE_URL}/compliments/${key}/${idOrText}`)

		if (data) {
			reply = `‚úÖ –ö–æ–º–ø–ª—ñ–º–µ–Ω—Ç–∏–∫ —É—Å–ø—ñ—à–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–æ –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö: ${JSON.stringify(data)}`
		} else {
			reply = '‚ÑπÔ∏è –¢–∞–∫–æ–≥–æ –∫–æ–º–ø–ª—ñ–º–µ–Ω—Ç–∏–∫–∞ —ñ –Ω–µ –±—É–ª–æ —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö'
		}
	} else if (command === 'upd') {
		const [collection, idFieldAndNewValue] = separateFirstWord(rest)
		const [id, fieldAndNewValue] = separateFirstWord(idFieldAndNewValue)
		const [field, newValue] = separateFirstWord(fieldAndNewValue)

		const { data } = await axios.patch(`${DB_BASE_URL}/${collection}/${id}`, {
			[field]: newValue,
		})

		if (data) {
			reply = `‚úÖ –ö–æ–º–ø–ª—ñ–º–µ–Ω—Ç–∏–∫ —É—Å–ø—ñ—à–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–æ —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö: ${JSON.stringify(data)}`
		} else {
			reply = `‚ö†Ô∏è –ö–æ–º–ø–ª—ñ–º–µ–Ω—Ç–∏–∫–∞ –∑ id ${id} –Ω–µ–º–∞—î –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö`
		}
	} else if (command === 'mlr') {
		await ctx.telegram.sendMessage(SWEET_CHAT_ID, rest)

		reply = '‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –õ—î–Ω—É—Å—ñ—á–∫—î –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ'
	} else if (command === 'msg') {
		const [name, surnameAndText] = separateFirstWord(rest)
		const [surname, text] = separateFirstWord(surnameAndText)

		const { data } = await axios.get(`${DB_BASE_URL}/users/${name}/${surname}`)

		if (data) {
			await ctx.telegram.sendMessage(data.chatId, text)
			reply = '‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ'
		} else {
			reply = '‚ö†Ô∏è –¢–∞–∫–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ–º–∞—î —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö'
		}
	} else if (command === 'u' || command === 'c') {
		let collection = ''
		if (command === 'u') collection = 'users'
		if (command === 'c') collection = 'compliments'

		const { data } = await axios.get(`${DB_BASE_URL}/${collection}`)

		reply = JSON.stringify(data.slice(rest * 20 - 20, rest * 20))
	} else if (ctx.message.text === '/uq' || ctx.message.text === '/cq') {
		let collection = ''
		if (command === '/uq') collection = 'users'
		if (command === '/cq') collection = 'compliments'

		const { data } = await axios.get(`${DB_BASE_URL}/${collection}`)

		reply = `${data.length}`
	} else if (ctx.message.text === '/test') {
		reply = '‚úÖ'
	} else {
		reply = '‚ö†Ô∏è –ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∞ –∫–æ–º–∞–Ω–¥–∞'
	}

	return reply
}

module.exports = async function handleText(ctx) {
	try {
		let reply

		if (isItKozubskyi(ctx)) {
			reply = await handleCreatorCommands(ctx)
		} else if (isItLenaRak(ctx)) {
			reply = '–Ø –ø–µ—Ä–µ–¥–∞–º –î–µ–Ω–∏—Å—É —Ç–µ, —â–æ —Ç–∏ –Ω–∞–ø–∏—Å–∞–ª–∞) üòò'
		} else {
			reply = '–Ø –ø–µ—Ä–µ–¥–∞–º –î–µ–Ω–∏—Å—É —Ü–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è üòâ'
		}

		await ctx.replyWithHTML(reply)

		await sendInfoMessageToCreator(ctx, reply)
	} catch (err) {
		await handleError({ ctx, err })
	}
}
